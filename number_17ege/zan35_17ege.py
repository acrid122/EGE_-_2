with open('17_25356 (1).txt') as f:
    sp = list(map(int, f)) #получение списка чисел из элементов файла


#Что найти?

count, max_s = 0, float('-inf') #максимум инициализируем минимальным значением, а минимум - максимальным float('inf')

max_30 = max(i for i in sp if abs(i) % 100 == 30)

#1 способ. По индексам
for i in range(len(sp) - 2): #чтобы не было ошибки - отсекаем лишние индексы
    x, y, z = sp[i : i + 3] #sp[i], sp[i + 1], sp[i + 2]
    pass

#2 способ. При помощи zip()
a = [1, 2, 3, 4]
b = [5, 6, 7, 8]

print(list(zip(a, b)))
#[(1, 5), (2, 6), (3, 7), (4, 8)]
a = [1, 2, 3, 4]
b = a[1:]

print(a, b)
'''
a = [1, 2, 3, 4]
b = [2, 3, 4]
c = a[2:]
c = [3, 4]
'''

'''
Если в задаче фигурируют отрицательные числа, то мы используем модуль в следующих случаях:

при проверке на N-значность.
1000 <= x <= 9999 -> правильнее 1000 <= abs(x) <= 9999

остатки от деления.
x % 10 -> abs(x) % 10

при переводе числа в строку для каких-либо действий тоже модуль, чтобы первый символ не был -
'''

def check_four(x):
    return 1000 <= abs(x) <= 9999

for x, y, z in zip(sp, sp[1:], sp[2:]):
    pass

for x, y, z in zip(sp, sp[1:], sp[2:]):
    '''
    1 способ, как обработать условие с 4-значностью. 
    Этот способ является наименее предпочтительным, так как могут встретиться условия, при которых требуется наличие РОВНО n-чисел, которые соотвествуют условию.
    if not(1000 <= abs(x) <= 9999) and not(1000 <= abs(y) <= 9999) and not(1000 <= abs(z) <= 9999):
    '''
    '''
    2 способ, как обработать условие с 4-значностью. 

    Создание функции.
    
    if len(list(filter(check_four, (x, y, z)))) == 0:
    
    У этого способа есть существенный минус - знание функции filter.

    a = [1, 2, 3, 4]

    print(list(filter(lambda x: x % 2 == 0, a)))
    '''
    '''
    3 способ, как обработать условие с 4-значностью.

    if sum(1 for i in (x, y, z) if 1000 <= abs(i) <= 9999) == 0:

    Способ наиболее предпочтительный. Реализуется при помощи встроенной функции sum(). При помощи этого способа можно точно посчитать, сколько должно
    быть подходящих/неподходящих значений  
    '''
    '''
    4 способ, как обработать условие с 4-значностью.

    if all(not(1000 <= abs(i) <= 9999) for i in (x, y, z))

    Способ подходит, если ВСЕ числа не должны/должны подходить какому-то условию
    ИЛИ
    if not any(not(1000 <= abs(i) <= 9999) for i in (x, y, z))
    '''
    '''
    На самом деле эти способы универсальны для любого условия, но если условие слишком сложное (недостаточно использования небольшого количества логических операций), то
    подойдет только второй способ.
    '''
    if sum(1 for i in (x, y, z) if 1000 <= abs(i) <= 9999) == 0 and (x + y + z) > max_30:
        count += 1
        max_s = max(x + y + z, max_s)
    
print(count, max_s)


with open('17_23952.txt') as f:
    sp = list(map(int, f))

count, summa = 0, 0

max_93 = max(i for i in sp if abs(i) % 100 == 93)

for x, y in zip(sp, sp[1:]):

    '''
    Исключающее ИЛИ
    Если операнды имеют различные логические значения, то Исключающее или даст True. Обозначается !=
    '''

    if (x > max_93) != (y > max_93): #ставим в скобки, чтобы сначала проверили с max_93, а потом проверилось условие
        if str(x)[0] == '9' or str(y)[0] == '9':
            count += 1
            if x > max_93:
                summa += x
            elif y > max_93:
                summa += y
    
print(count, summa)


with open('17_23949.txt') as f:
    sp = list(map(int, f))

count, summa = 0, 0

for i in range(len(sp) - 2):
    s = sp[i : i + 3]
    if sum(1 for j in s if str(j)[0] == str(j)[-1]) == 1 \
    and sum(1 for j in s if 10 ** 4 <= abs(j) <= 99999 and abs(j) // 1000 % 10 == 7) == 2:
        count += 1
        summa += max(s)

print(count, summa)
